public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }

private Map<Integer,Integer> counter = new HashMap<Integer,Integer>();

    public boolean isValidBST(TreeNode root) {

        boolean isBST = false;

        if(counter.isEmpty()){
            if(hasDuplicate(root))
                return false;
        }

        if(root.left == null && root.right == null)
            return true;

        if(ChildCount(root) == 0){
            isBST = true;
        }
        
        if(ChildCount(root) == 1){
            if(root.left != null){

                if(root.left.val < root.val){

                    isBST = isValidBST(root.left);
                }
                    

                if(max(root.left).val > root.val)
                    isBST = false;
            }
            else
            {
                if(root.right.val > root.val){
                    isBST = isValidBST(root.right);
                }
                    

                if(min(root.right).val < root.val)
                    isBST = false;
            }

            
        }

        if(ChildCount(root) == 2){

                if(root.left.val < root.val && root.right.val > root.val){
                    boolean isLeftValidBST = isValidBST(root.left);
                    boolean isRightValidBST = isValidBST(root.right);
                    isBST = isLeftValidBST && isRightValidBST;
                }       

                if(min(root.right).val < root.val)
                    isBST = false;

                if(max(root.left).val > root.val)
                    isBST = false;

        }

        return isBST;
       
    }

    private int ChildCount(TreeNode root){
	
        int childCount = -1;
        if(root.left == null && root.right == null){
            childCount = 0;
        }
        else if(root.left != null && root.right != null){
            childCount = 2;
        }
        else{
            childCount = 1;
        }
        
        return childCount;

    }

    private TreeNode min(TreeNode root){

        if(root == null)
            return null;
        
        if(root.left == null)
            return root;

       return min(root.left);
    }

    private TreeNode max(TreeNode root){

        if(root == null)
            return null;
        
        if(root.right == null)
            return root;

       return max(root.right);
    }

    private void scanDuplicate(TreeNode root){
        
        if(root == null)
            return;

       Integer count;

       if(counter.get(root.val) == null)
            count = 0;
       else
            count = counter.get(root.val); 

       count++;

       counter.put(root.val,count);

       scanDuplicate(root.left);
       
       scanDuplicate(root.right);
       
    }

    private boolean hasDuplicate(TreeNode root){

        scanDuplicate(root);

        for(Map.Entry<Integer,Integer> m:counter.entrySet()){
           if(m.getValue() > 1)
                return true;
       }
       return false;
    }

public TreeNode deleteNode(TreeNode root, int key) {
        return delete(null,root,key);
    }

    private TreeNode delete(TreeNode parent,TreeNode root,int data){

        if(root == null) return null;

        if(data == root.val){

            if(parent == null){
                root = ReorderRoot(root);
            }
            else if(parent.left == root){
                ReorderNodesLeft(parent,root);
            }
            else if(parent.right == root){
                ReorderNodesRight(parent,root);
            }
            
        }
        else if(data < root.val){
            delete(root,root.left,data);
            
        }
        else if(data > root.val){
            delete(root,root.right,data);
            
        }
        return root;
    }

    private TreeNode ReorderRoot(TreeNode root){

        if(ChildCount(root) ==2){
		  TreeNode minNode = min(root.right);
          minNode.left = root.left;
          root = root.right;
		}
		else {
		  TreeNode child = root.left;
		   if(child == null)
			child = root.right;
		   root = child;
		}
        return root;
    }

    private TreeNode min(TreeNode root){

        if(root == null)
            return null;
        
        if(root.left == null)
            return root;

       return min(root.left);
    }

    private void ReorderNodesLeft(TreeNode parent, TreeNode root){
		
		
		if(ChildCount(root) ==2){
          
          TreeNode minNode = min(root.right);
          minNode.left = root.left;
		  parent.left = root.right;
		  root = null;
		}
		else {
		  TreeNode child = root.left;
		   if(child == null)
			child = root.right;
		   root = null;
		   parent.left = child;
		}

    }

    private void ReorderNodesRight(TreeNode parent, TreeNode root){
            
            
            if(ChildCount(root) ==2){
            parent.right = root.right;
            TreeNode minNode = min(parent.right);
            minNode.left = root.left;
            root = null;
            }
            else {
            TreeNode child = root.left;
            if(child == null)
                child = root.right;
            root = null;
            parent.right = child;
            }

    }

    private int ChildCount(TreeNode root){
	
        int childCount = -1;
        if(root.left == null && root.right == null){
            childCount = 0;
        }
        else if(root.left != null && root.right != null){
            childCount = 2;
        }
        else{
            childCount = 1;
        }
        
        return childCount;

    }
  }
